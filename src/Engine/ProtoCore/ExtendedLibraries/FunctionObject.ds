class _FunctionObject
{
    def DoEvaluation(v:var[]..[])
    {
        return = null;
    }
}

class _SingleFunctionObject extends _FunctionObject
{
    __functionPointers : function;
    __argumtNumber : int;
    __params : var[]..[];
    __hasParamAt : bool[];
    
    constructor _SingleFunctionObject(fptr : function, 
                                      argNumber: int, 
                                      paramPositions : int[], 
                                      params : var[]..[])
    {
        __functionPointers = fptr;
        __argumtNumber = argNumber;
        
        __hasParamAt[0..__argumtNumber - 1] = false;
        __hasParamAt[paramPositions] = true;
        
        __params = params;
    }
    
    private def GetNextEmptyParamPos(hasParamAt : bool[])
    {
        return = [Imperative]
        {
            for(_i in 0..Count(hasParamAt) - 1)
            {
                if (!hasParamAt[_i])
                    return = _i;
            }
            return = -1;
        }
    }
    
    private def DoEvaluationImp(fptr : function, 
                              params : var[]..[])
    {
        return = Evaluate(fptr, params);
    }
    
    def DoEvaluation(param: var[]..[])
    {      
        return = [Imperative]
        {           
            _nextParamPosition = GetNextEmptyParamPos(__hasParamAt);
            
            if (_nextParamPosition < 0)
            {
                return = null;
            }
            else
            {
                _params = __params;
                _hasParamAt = __hasParamAt;
                
                _params[_nextParamPosition] = param;
                _hasParamAt[_nextParamPosition] = true;
                
                _nextParamPosition = GetNextEmptyParamPos(_hasParamAt);
                if (_nextParamPosition < 0)
                {
                    return = DoEvaluationImp(__functionPointers, _params);
                }
                else
                {
                    _paramPositions = { };
                    for (_i in 0..__argumtNumber - 1)
                    {
                        if (_hasParamAt[_i])
                        {
                            _paramPositions = Concat(_paramPositions, { _i });
                        }
                    }
                
                    return = _SingleFunctionObject._SingleFunctionObject(
                                                __functionPointers,
                                                __argumtNumber,
                                                _paramPositions,
                                                _params);
                }
            }
        }  
    }
}

class _ComposedFunctionObject extends _FunctionObject
{
    __funcs : _FunctionObject[];
    
    constructor _ComposedFunctionObject(funcs : _FunctionObject[])
    {
        __funcs = funcs;
    }
    
    def DoEvaluation(param:var[]..[])
    {
        return = [Imperative]
        {
            _count = Count(__funcs);
            _v = param;
            
            for(_i in _count - 1.. 0)
            {
                _f = __funcs[_i];
                _v = _f.DoEvaluation(_v);
            }
            return = _v;
        }
    }
}

def Apply(functionObject: _FunctionObject, param: var[]..[])
{
    return = functionObject.DoEvaluation(param);
}

def Compose(funcs : _FunctionObject[])
{
    return = _ComposedFunctionObject(funcs);
}

def MinimumItemByKey(list: var[], keyProjector: _FunctionObject)
{
    return = [Imperative]
    {
        _count = Count(list);
        if (_count == 0)
        {
            return = null;
        }

        _min = list[0];
        _minProjection = Apply(keyProjector, list[0]);

        for (_index in 1..(_count - 1))
        {
            _currentProjection = Apply(keyProjector, list[_index]);
            if (_currentProjection < _minProjection)
            {
                _min = list[_index];
                _minProjection = _currentProjection;
            }
        }

        return = _min;
    }
}

def MaximumItemByKey(list: var[], keyProjector: _FunctionObject)
{
    return = [Imperative]
    {
        if (list == null)
        {
            return = null;
        }

        _count = Count(list);
        if (_count == 0)
        {
            return = null;
        }

        _max = list[0];
        _maxProjection = Apply(keyProjector, list[0]);

        for (_index in 1..(_count - 1))
        {
            _currentProjection = Apply(keyProjector, list[_index]);
            if (_currentProjection > _maxProjection)
            {
                _max = list[_index];
                _maxProjection = _currentProjection;
            }
        }

        return = _max;
    }
}

def Filter(list: var[], predicate: _FunctionObject)
{
    return = [Imperative]
    {
        if (list == null) 
        {
            return = null;
        }

        _count = Count(list);
        if (_count == 0)
        {
            return = {};
        }

        _filteredList = {};
        _current = 0;

        for (_index in 0..(_count - 1))
        {
            _value = list[_index];
            if (Apply(predicate, _value))
            {
                _filteredList[_current] = _value;
                _current = _current + 1;
            }
        }

        return = _filteredList;
    }
}

def FilterOut(list: var[], predicate: _FunctionObject)
{
    return = [Imperative]
    {
        if (list == null) 
        {
            return = null;
        }

        _count = Count(list);
        if (_count == 0)
        {
            return = {};
        }

        _filteredList = {};
        _current = 0;

        for (_index in 0..(_count - 1))
        {
            _value = list[_index];
            if (!Apply(predicate, _value))
            {
                _filteredList[_current] = _value;
                _current = _current + 1;
            }
        }

        return = _filteredList;
    }
}

def Map(list : var[], projector: _FunctionObject)
{
    return = [Imperative]
    {
        if (list == null)
        {
            return= null;
        }
        
        _mappedList = { };
        for (_index in 0..(Count(list) - 1))
        {
            _mappedList[_index] = Apply(projector, list[_index]);
        }
                
        return = _mappedList;
    }
}

def SortByKey(list : var[], keyProjector:_FunctionObject)
{
    return = [Imperative]
    {
        _count = Count(list);
        if (_count < 2)
        {
            return = list;
        }
        
        _pivotKey = Apply(keyProjector, list[0]);
        // The position of last element that < privot
        _last = 0;
        
        for (_current in 1..(_count - 1))
        {
            _currentKey = Apply(keyProjector, list[_current]);
            if (_currentKey < _pivotKey)
            {
                _last = _last + 1;
                
                _temp = list[_current];
                list[_current] = list[_last];
                list[_last] = _temp;
            }
        }        
        
        _temp = list[_last];
        list[_last] = list[0];
        list[0] = _temp;
        
        _leftList = { };
        if (_last >= 1)
        {
            _leftList = list[0.._last - 1];
        }
        
        _rightList = { };
        if (_last < _count - 1)
        {
            _rightList = list[(_last + 1)..(_count - 1)];
        }
        
        return = Concat(Concat(SortByKey(_leftList, keyProjector), { list[_last] }), SortByKey(_rightList, keyProjector));
    }
}

def SortByComparsion(list : var[], comparer:_FunctionObject)
{
    return = [Imperative]
    {
        _count = Count(list);
        if (_count < 2)
        {
            return = list;
        }
        
        _pivotComparer = Apply(comparer, list[0]);
        // The position of last element that < privot
        _last = 0;
        
        for (_current in 1..(_count - 1))
        {
            // comparer(pivot, current) >= 0 ?
            if (Apply(_pivotComparer, list[_current]) > 0)
            {
                _last = _last + 1;
                
                _temp = list[_current];
                list[_current] = list[_last];
                list[_last] = _temp;
            }
        }        
        
        _temp = list[_last];
        list[_last] = list[0];
        list[0] = _temp;
        
        _leftList = { };
        if (_last >= 1)
        {
            _leftList = list[0.._last - 1];
        }
        
        _rightList = { };
        if (_last < _count - 1)
        {
            _rightList = list[(_last + 1)..(_count - 1)];
        }
        
        return = Concat(Concat(SortByComparsion(_leftList, comparer), { list[_last] }), SortByComparsion(_rightList, comparer));
    }
}

def GroupByKey(list : var[], keyProjector: _FunctionObject)
{
    return = [Imperative]
    {
        if (list == null)
        {
            return= null;
        }
        
        _groupedList = { };
        for (_index in 0..(Count(list) - 1))
        {
            _key = Apply(keyProjector, list[_index]);
            if (!ContainsKey(_groupedList, _key))
            {
                _groupedList[_key] = { };
            }
            
            _subList = _groupedList[_key];
            _groupedList[_key] = Concat(_subList, { list[_index] });
        }
        
        _finalGroupedList = { };
        _current = 0;
        _keys = GetKeys(_groupedList);
        
        for (_index in 0..(Count(_keys) - 1))
        {
            _key = _keys[_index];
            _subList = _groupedList[_keys[_index]];
            
            if (_subList!= null)
            {
                _finalGroupedList[_current] = _subList;
                _current = _current + 1;
            }
        }
        
        return = _finalGroupedList;
    }
}

def Reduce(list : var[], seed:var, accumulator : _FunctionObject)
{
    return = [Imperative]
    {
        if (list == null)
        {
            return = seed;
        }
        
        _acc = seed;
        for (_index in 0..(Count(list) - 1))
        {
            _accFunc = Apply(accumulator, _acc);
            _acc = Apply(_accFunc, list[_index]);
        }
        
        return = _acc;
    }
}