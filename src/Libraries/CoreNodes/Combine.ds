//import("DSCoreNodes.dll");

def Combine(func, lists : var[]..[])
{
    argList = Transpose(lists);
    return = [Imperative]
    {
        result = { };
        for(args in argList)
        {
            result[Count(result)] = Evaluate(func, args);
        }
        return = result;
    };
}

def ForEach(func, lists : var[]..[])
{
    argList = Transpose(lists);
    [Imperative]
    {
        for(args in argList)
        {
            Evaluate(func, args);
        }
    };
}

def Reduce(func, acc, lists : var[]..[])
{
    argList = Transpose(lists);
    return = [Imperative]
    {
        for(args in argList)
        {
            args[Count(args)] = acc;
            acc = Evaluate(func, args);
        }
        return = acc;
    };
}

def Filter(list : var[]..[], predicate)
{
    return = [Imperative]
    {
        resultIn = {};
        resultOut = {};

        for(item in list)
        {
            if (Evaluate(predicate, item))
            {
                resultIn[Count(resultIn)] = item;
            }
            else
            {
                resultOut[Count(resultOut)] = item;
            }
        }
        return = { resultIn, resultOut };
    };
}

def LaceShortest(func, lists : var[]..[])
{
    return = [Imperative]
    {
        shortestLen = -1;
        for(item in lists)
        {
            count = Count(item);
            if (shortestLen < 0 || count < shortestLen)
            {
                shortestLen = count;
            }
        }
        Print(shortestLen);
        shortenedLists = { };
        for(item in lists)
        {
            if (shortestLen == 1)
            {
                shortenedLists[Count(shortenedLists)] = { item[0] };
            }
            else
            {
                shortenedLists[Count(shortenedLists)] = item[0..shortestLen - 1];
            }
        }
        return = Combine(func, shortenedLists);
    };
}

def LaceLongest(func, lists : var[]..[])
{
    return = [Imperative]
    {
        longestLen = 0;
        for(item in lists)
        {
            count = Count(item);
            if (count > longestLen)
            {
                longestLen = count;
            }
        }
        stretchedLists = { };
        for(item in lists)
        {
            count = Count(item);
            last = item[count-1];
            amtToAdd = longestLen - count;
            if (amtToAdd == 0)
            {
                stretchedLists[Count(stretchedLists)] = item[0..count - 1];
            }
            else
            {
                repeated = { };
                repeated[0..amtToAdd-1] = last;
                stretchedLists[Count(stretchedLists)] = Concat(item, repeated);
            }
        }
        return = Combine(func, stretchedLists);
    };
}

def CartesianProduct(func, lists : var[]..[])
{
    return = [Imperative]
    {
        count = Count(lists);
        if (count == 0)
        {
            return = lists;
        }
        
        argLists = { };
        for(item in lists[0])
        {
            argLists[Count(argLists)] = { item };
        }

        if (count > 1)
        {
            nextLists = { };
            
            if (count == 2)
            {
                nextLists = { lists[1] };
            }
            else
            {
                nextLists = lists[1..count - 1];
            }
            
            for(list in nextLists)
            {
                newArgs = { };
                for(item in list)
                {
                    for(argList in argLists)
                    {
                        newArgs[Count(newArgs)] = Concat(argList, { item });
                    }
                }
                Print(newArgs);
                argLists = newArgs;
            }
        }
        
        results = { };
        for(args in argLists)
        {
            results[Count(results)] = Evaluate(func, args);
        }
        return = results;
    };
}

def TrueForAny(predicate, list : var[]..[])
{
    return = [Imperative]
    {
        for(item in list)
        {
            if (Evaluate(predicate, { item }))
            {
                return = true;
            }
        }
        return = false;
    };
}

def TrueForAll(predicate, list : var[]..[])
{
    return = [Imperative]
    {
        for(item in list)
        {
            if (!Evaluate(predicate, { item }))
            {
                return = false;
            }
        }
        return = true;
    };
}

def __map(func, list : var[]..[])
{
    return = [Imperative]
    {
        mapped = { };
        for(item in list)
        {
            mapped[Count(mapped)] = Evaluate(func, { item });
        }
        return = mapped;
    };
}

def MinByKey(func, list : var[]..[])
{
    return = DSCore.Sorting.minByKey(list, __map(func, list));
}

def MaxByKey(func, list : var[]..[])
{
    return = DSCore.Sorting.maxByKey(list, __map(func, list));
}

def SortByKey(func, list : var[]..[])
{
    return = DSCore.Sorting.sortByKey(list, __map(func, list));
}
